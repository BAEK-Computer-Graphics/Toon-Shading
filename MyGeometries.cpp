//
//  MyGeometries.cpp
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//

#pragma warning(disable:4996)

#include <vector>

#define GLEW_STATIC
#include "GL/glew.h" 
#include "GLFW/glfw3.h"

#include "LinearR3.h"
#include "LinearR4.h"
#include "MathMisc.h"

#include "ShaderBuild.h"

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"

using namespace std;

// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
phMaterial materialUnderTexture;

// Information for loading textures
const int NumTextures = 6;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "ears.bmp",
    "hair.bmp",
    "shirt.bmp",
    "shirtarms.bmp",
	"face.bmp",
	"whistle.bmp"
};

int numSuzElts = 0;
int numHairElts = 0;
int numEarElts = 0;
int numShirtElts = 0;
int numShirtarmsElts = 0;
int numWhistleElts = 0;


// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************
const int NumObjects = 8;
const int iFloor = 0;
const int iCircularSurf = 1;
const int iWall = 2;
const int iEar = 3;
const int iHair = 4;
const int iShirt = 5;
const int iShirtarms = 6;
const int iWhistle = 7;

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

// Set up texture maps

void SetupForTextures()
{
    // This material goes under the textures.
    // IY YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE TO DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.9, 0.9, 0.9);
    materialUnderTexture.AmbientColor.Set(0.7, 0.7, 0.7);
    materialUnderTexture.DiffuseColor.Set(0.8, 0.8, 0.8);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    // Load texture maps
    RgbImage texMap;

    glUseProgram(phShaderPhongPhong);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);

    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the phShaderPhongPhong uses the GL_TEXTURE_0 texture.
    glUseProgram(phShaderPhongPhong);
    glUniform1i(glGetUniformLocation(phShaderPhongPhong, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// Set up geometries

void MySetupSurfaces()
{
    // Initialize VAOs, VBOs, and EBOs 

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);


    // Back wall

    float wallVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -50.0f, 50.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Top left
         50.0f, 50.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Top right
         50.0f, -50.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Bottom right
        -50.0f, -50.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Bottom left
    };
    unsigned int wallElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
    glBindVertexArray(myVAO[iWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts), wallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3*sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wallElts) * sizeof(unsigned int), wallElts, GL_STATIC_DRAW);


    // Floor

	float floorVerts[] = {
		// Position              // Normal                  // Texture coordinates
		-5.0f, 0.0f, -5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Top left
		5.0f, 0.0f, -5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Top right
		5.0f, 0.0f, 5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Bottom right
		-5.0f, 0.0f, 5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Bottom left
	};
	unsigned int floorElts[] = { 0, 3, 1, 2 };
	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
	glBindVertexArray(myVAO[iFloor]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts) * sizeof(unsigned int), floorElts, GL_STATIC_DRAW);


	// Face

	vector<vector<float>> out_vertices;
	vector<unsigned int> out_elements;
	loadOBJ("face.obj", out_vertices, out_elements);
	int numSuzVerts = out_vertices.size();
	float* suzVerts = new float[8 * numSuzVerts];

	for (int i = 0; i < numSuzVerts; i++) {
		for (int j = 0; j < 8; j++) {

			suzVerts[(8 * i) + j] = out_vertices[i][j];
			
			/*
			if (j == 3)
			{
				suzVerts[(8 * i) + j] = -1.0f;
			}
			if (j == 4)
			{
				suzVerts[(8 * i) + j] = 0.0f;
			}
			if (j == 5)
			{
				suzVerts[(8 * i) + j] = 1.0f;
			}
			*/
		}
	}

	numSuzElts = out_elements.size();
	unsigned int* suzElts = new unsigned int[numSuzElts];

	for (int i = 0; i < numSuzElts; i++)
	{
		suzElts[i] = out_elements[i];
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
	glBindVertexArray(myVAO[iCircularSurf]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numSuzVerts * sizeof(float), suzVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numSuzElts * sizeof(unsigned int), suzElts, GL_STATIC_DRAW);

	delete[] suzVerts;
	delete[] suzElts;
	out_vertices.clear();
	out_elements.clear();


	// Hair

	loadOBJ("hairglasses.obj", out_vertices, out_elements);
	int numHairVerts = out_vertices.size();
	float* hairVerts = new float[8 * numHairVerts];

	for (int i = 0; i < numHairVerts; i++) {
		for (int j = 0; j < 8; j++) {

			hairVerts[(8 * i) + j] = out_vertices[i][j];
		}
	}

	numHairElts = out_elements.size();
	unsigned int* hairElts = new unsigned int[numHairElts];

	for (int i = 0; i < numHairElts; i++)
	{
		hairElts[i] = out_elements[i];
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iHair]);
	glBindVertexArray(myVAO[iHair]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numHairVerts * sizeof(float), hairVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iHair]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numHairElts * sizeof(unsigned int), hairElts, GL_STATIC_DRAW);

	delete[] hairVerts;
	delete[] hairElts;
	out_vertices.clear();
	out_elements.clear();


	// Arms and ears

	loadOBJ("armsears.obj", out_vertices, out_elements);
	int numEarVerts = out_vertices.size();
	float* earVerts = new float[8 * numEarVerts];

	for (int i = 0; i < numEarVerts; i++) {
		for (int j = 0; j < 8; j++) {

			earVerts[(8 * i) + j] = out_vertices[i][j];
		}
	}

	numEarElts = out_elements.size();
	unsigned int* earElts = new unsigned int[numEarElts];

	for (int i = 0; i < numEarElts; i++)
	{
		earElts[i] = out_elements[i];
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iEar]);
	glBindVertexArray(myVAO[iEar]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numEarVerts * sizeof(float), earVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iEar]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numEarElts * sizeof(unsigned int), earElts, GL_STATIC_DRAW);

	delete[] earVerts;
	delete[] earElts;
	out_vertices.clear();
	out_elements.clear();


	// Shirt

	loadOBJ("shirt.obj", out_vertices, out_elements);
	int numShirtVerts = out_vertices.size();
	float* shirtVerts = new float[8 * numShirtVerts];

	for (int i = 0; i < numShirtVerts; i++) {
		for (int j = 0; j < 8; j++) {

			shirtVerts[(8 * i) + j] = out_vertices[i][j];
		}
	}

	numShirtElts = out_elements.size();
	unsigned int* shirtElts = new unsigned int[numShirtElts];

	for (int i = 0; i < numShirtElts; i++)
	{
		shirtElts[i] = out_elements[i];
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iShirt]);
	glBindVertexArray(myVAO[iShirt]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numShirtVerts * sizeof(float), shirtVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iShirt]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numShirtElts * sizeof(unsigned int), shirtElts, GL_STATIC_DRAW);

	delete[] shirtVerts;
	delete[] shirtElts;
	out_vertices.clear();
	out_elements.clear();


	// Shoulders

	loadOBJ("shirtarms.obj", out_vertices, out_elements);
	int numShirtarmsVerts = out_vertices.size();
	float* shirtarmsVerts = new float[8 * numShirtarmsVerts];

	for (int i = 0; i < numShirtarmsVerts; i++) {
		for (int j = 0; j < 8; j++) {

			shirtarmsVerts[(8 * i) + j] = out_vertices[i][j];
		}
	}

	numShirtarmsElts = out_elements.size();
	unsigned int* shirtarmsElts = new unsigned int[numShirtarmsElts];

	for (int i = 0; i < numShirtarmsElts; i++)
	{
		shirtarmsElts[i] = out_elements[i];
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iShirtarms]);
	glBindVertexArray(myVAO[iShirtarms]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numShirtarmsVerts * sizeof(float), shirtarmsVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iShirtarms]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numShirtarmsElts * sizeof(unsigned int), shirtarmsElts, GL_STATIC_DRAW);

	delete[] shirtarmsVerts;
	delete[] shirtarmsElts;
	out_vertices.clear();
	out_elements.clear();


	// Whistle

	loadOBJ("whistle.obj", out_vertices, out_elements);
	int numWhistleVerts = out_vertices.size();
	float* whistleVerts = new float[8 * numWhistleVerts];

	for (int i = 0; i < numWhistleVerts; i++) {
		for (int j = 0; j < 8; j++) {

			whistleVerts[(8 * i) + j] = out_vertices[i][j];
		}
	}

	numWhistleElts = out_elements.size();
	unsigned int* whistleElts = new unsigned int[numWhistleElts];

	for (int i = 0; i < numWhistleElts; i++)
	{
		whistleElts[i] = out_elements[i];
	}

	glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWhistle]);
	glBindVertexArray(myVAO[iWhistle]);
	glBufferData(GL_ARRAY_BUFFER, 8 * numWhistleVerts * sizeof(float), whistleVerts, GL_STATIC_DRAW);
	glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
	glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
	glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
	glVertexAttribPointer(vertTexCoords_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
	glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWhistle]);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, numWhistleElts * sizeof(unsigned int), whistleElts, GL_STATIC_DRAW);

	delete[] whistleVerts;
	delete[] whistleElts;
	out_vertices.clear();
	out_elements.clear();

    check_for_opengl_errors();
}


// Load an OBJ file

bool loadOBJ(const char* path, vector<vector<float>> & out_vertices, vector<unsigned int> & out_elements)
{
	vector<unsigned int> vertexIndices;
	vector<unsigned int> uvIndices;
	vector<unsigned int> normalIndices;
	vector<float> temp_vertices_x;
	vector<float> temp_vertices_y;
	vector<float> temp_vertices_z;
	vector<float> temp_uvs_x;
	vector<float> temp_uvs_y;
	vector<float> temp_normals_x;
	vector<float> temp_normals_y;
	vector<float> temp_normals_z;

	FILE* file = fopen(path, "r");

	if (file == NULL) {
		printf("Failed to load OBJ file\n");
		return false;
	}

	while (1) {
		char lineHeader[128];

		// Read first word of line
		int res = fscanf(file, "%s", lineHeader);

		if (res == EOF) {
			break;
		}

		if (strcmp(lineHeader, "v") == 0) {
			float x, y, z;
			fscanf(file, "%f %f %f\n", &x, &y, &z);
			temp_vertices_x.push_back(x);
			temp_vertices_y.push_back(y);
			temp_vertices_z.push_back(z);
		}
		else if (strcmp(lineHeader, "vt") == 0) {
			float x, y;
			fscanf(file, "%f %f\n", &x, &y);
			temp_uvs_x.push_back(x);
			temp_uvs_y.push_back(y);
		}
		else if (strcmp(lineHeader, "vn") == 0) {
			float x, y, z;
			fscanf(file, "%f %f %f\n", &x, &y, &z);
			temp_normals_x.push_back(x);
			temp_normals_y.push_back(y);
			temp_normals_z.push_back(z);
		}
		else if (strcmp(lineHeader, "f") == 0) {
			std::string vertex1, vertex2, vertex3;
			unsigned int vertexIndex[3], uvIndex[3], normalIndex[3];

			int matches = fscanf(file, "%d/%d/%d %d/%d/%d %d/%d/%d\n", &vertexIndex[0], &uvIndex[0], &normalIndex[0],
				&vertexIndex[1], &uvIndex[1], &normalIndex[1], &vertexIndex[2], &uvIndex[2], &normalIndex[2]);

			if (matches != 9) {
				printf("OBJ file is not readable\n");
				return false;
			}

			vertexIndices.push_back(vertexIndex[0]);
			vertexIndices.push_back(vertexIndex[1]);
			vertexIndices.push_back(vertexIndex[2]);
			uvIndices.push_back(uvIndex[0]);
			uvIndices.push_back(uvIndex[1]);
			uvIndices.push_back(uvIndex[2]);
			normalIndices.push_back(normalIndex[0]);
			normalIndices.push_back(normalIndex[1]);
			normalIndices.push_back(normalIndex[2]);
		}
	}

	// For each face: if vertex with same tex coord and normal has been stored reuse it, otherwise use duplicate vertex
	// Return vertex array and element array (through reference in parameter)

	for (unsigned int i = 0; i < vertexIndices.size(); i++) {
		
		unsigned int vertexIndex = vertexIndices[i];
		unsigned int normalIndex = normalIndices[i];
		unsigned int textureIndex = uvIndices[i];

		vector<float> element;
		element.push_back(temp_vertices_x[vertexIndex - 1]);
		element.push_back(temp_vertices_y[vertexIndex - 1]);
		element.push_back(temp_vertices_z[vertexIndex - 1]);
		element.push_back(temp_normals_x[normalIndex - 1]);
		element.push_back(temp_normals_y[normalIndex - 1]);
		element.push_back(temp_normals_z[normalIndex - 1]);
		element.push_back(temp_uvs_x[textureIndex - 1]);
		element.push_back(temp_uvs_y[textureIndex - 1]);

		out_vertices.push_back(element);
		out_elements.push_back(i);
	}

	return true;
}


void MyRenderGeometries()
{
	
	/*
    // Render the floor

	LinearMapR4 matDemo = viewMatrix;
	matDemo.Mult_glTranslate(0.0, -2.0, 0.0);
    glBindVertexArray(myVAO[iFloor]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[6]);     // Choose marble texture
													   // Draw the floor as a single triangle strip
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
	*/

	// Render Face

	LinearMapR4 matDemo = viewMatrix;
	matDemo.Mult_glTranslate(0.0, 5.0, 0.0);
	glBindVertexArray(myVAO[iCircularSurf]);
	materialUnderTexture.LoadIntoShaders();
	matDemo.DumpByColumns(matEntries);
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[4]);

	glDrawElements(GL_TRIANGLES, numSuzElts, GL_UNSIGNED_INT, (void*)0);


	// Hair

	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(0.0, 5.0, 0.0);
	glBindVertexArray(myVAO[iHair]);
	materialUnderTexture.LoadIntoShaders();
	matDemo.DumpByColumns(matEntries);
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[1]);

	glDrawElements(GL_TRIANGLES, numHairElts, GL_UNSIGNED_INT, (void*)0);


	// Ears and arms

	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(0.0, 5.0, 0.0);
	glBindVertexArray(myVAO[iEar]);
	materialUnderTexture.LoadIntoShaders();
	matDemo.DumpByColumns(matEntries);
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[0]);

	glDrawElements(GL_TRIANGLES, numEarElts, GL_UNSIGNED_INT, (void*)0);


	// Shirt

	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(0.0, 5.0, 0.0);
	glBindVertexArray(myVAO[iShirt]);
	materialUnderTexture.LoadIntoShaders();
	matDemo.DumpByColumns(matEntries);
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[2]);

	glDrawElements(GL_TRIANGLES, numShirtElts, GL_UNSIGNED_INT, (void*)0);


	// Shoulders

	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(0.0, 5.0, 0.0);
	glBindVertexArray(myVAO[iShirtarms]);
	materialUnderTexture.LoadIntoShaders();
	matDemo.DumpByColumns(matEntries);
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[3]);

	glDrawElements(GL_TRIANGLES, numShirtarmsElts, GL_UNSIGNED_INT, (void*)0);


	// Whistle

	matDemo = viewMatrix;
	matDemo.Mult_glTranslate(0.0, 5.0, 0.0);
	glBindVertexArray(myVAO[iWhistle]);
	materialUnderTexture.LoadIntoShaders();
	matDemo.DumpByColumns(matEntries);
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[5]);

	glDrawElements(GL_TRIANGLES, numWhistleElts, GL_UNSIGNED_INT, (void*)0);
	

    check_for_opengl_errors();
}


void MyRenderPass2()
{
	// Render the Back Wall

	LinearMapR4 matDemo;
	const double zDistance = 20.0;              // Make this value larger or smaller to affect field of view.
	const double Zmax = -0.0;   // Control z dimensions of the viewable scene
	double ZextraDistance = 0.0;              // Extra distance we have moved to/from the scene
	matDemo.Set_glTranslate(0.0, 0.0, -(Zmax + zDistance + ZextraDistance));      // Translate to be in front of the camera

	glBindVertexArray(myVAO[iWall]);                // Select the back wall VAO (Vertex Array Object)
	materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
	matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

	glUniform1i(applyTextureLocation, 0); 

    check_for_opengl_errors();
}
